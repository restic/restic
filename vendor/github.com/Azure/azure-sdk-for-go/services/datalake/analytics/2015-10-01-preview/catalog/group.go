package catalog

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"net/http"
)

// GroupClient is the creates an Azure Data Lake Analytics catalog client.
type GroupClient struct {
	ManagementClient
}

// NewGroupClient creates an instance of the GroupClient client.
func NewGroupClient() GroupClient {
	return GroupClient{New()}
}

// CreateSecret creates the specified secret for use with external data sources in the specified database.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database in which to create the secret. secretName is the name of the secret. parameters is the parameters
// required to create the secret (name and password)
func (client GroupClient) CreateSecret(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (result USQLSecret, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: parameters,
			Constraints: []validation.Constraint{{Target: "parameters.Password", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "catalog.GroupClient", "CreateSecret")
	}

	req, err := client.CreateSecretPreparer(accountName, databaseName, secretName, parameters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "CreateSecret", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "CreateSecret", resp, "Failure sending request")
		return
	}

	result, err = client.CreateSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "CreateSecret", resp, "Failure responding to request")
	}

	return
}

// CreateSecretPreparer prepares the CreateSecret request.
func (client GroupClient) CreateSecretPreparer(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"secretName":   autorest.Encode("path", secretName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/secrets/{secretName}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// CreateSecretSender sends the CreateSecret request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) CreateSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateSecretResponder handles the response to the CreateSecret request. The method always
// closes the http.Response Body.
func (client GroupClient) CreateSecretResponder(resp *http.Response) (result USQLSecret, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteAllSecrets deletes all secrets in the specified database
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the secret.
func (client GroupClient) DeleteAllSecrets(accountName string, databaseName string) (result autorest.Response, err error) {
	req, err := client.DeleteAllSecretsPreparer(accountName, databaseName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteAllSecrets", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteAllSecretsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteAllSecrets", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteAllSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteAllSecrets", resp, "Failure responding to request")
	}

	return
}

// DeleteAllSecretsPreparer prepares the DeleteAllSecrets request.
func (client GroupClient) DeleteAllSecretsPreparer(accountName string, databaseName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/secrets", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteAllSecretsSender sends the DeleteAllSecrets request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteAllSecretsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteAllSecretsResponder handles the response to the DeleteAllSecrets request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteAllSecretsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSecret deletes the specified secret in the specified database
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the secret. secretName is the name of the secret to delete
func (client GroupClient) DeleteSecret(accountName string, databaseName string, secretName string) (result autorest.Response, err error) {
	req, err := client.DeleteSecretPreparer(accountName, databaseName, secretName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteSecret", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSecretSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteSecret", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "DeleteSecret", resp, "Failure responding to request")
	}

	return
}

// DeleteSecretPreparer prepares the DeleteSecret request.
func (client GroupClient) DeleteSecretPreparer(accountName string, databaseName string, secretName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"secretName":   autorest.Encode("path", secretName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/secrets/{secretName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteSecretSender sends the DeleteSecret request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteSecretResponder handles the response to the DeleteSecret request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteSecretResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetAssembly retrieves the specified assembly from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the assembly. assemblyName is the name of the assembly.
func (client GroupClient) GetAssembly(accountName string, databaseName string, assemblyName string) (result USQLAssembly, err error) {
	req, err := client.GetAssemblyPreparer(accountName, databaseName, assemblyName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetAssembly", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAssemblySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetAssembly", resp, "Failure sending request")
		return
	}

	result, err = client.GetAssemblyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetAssembly", resp, "Failure responding to request")
	}

	return
}

// GetAssemblyPreparer prepares the GetAssembly request.
func (client GroupClient) GetAssemblyPreparer(accountName string, databaseName string, assemblyName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"assemblyName": autorest.Encode("path", assemblyName),
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/assemblies/{assemblyName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetAssemblySender sends the GetAssembly request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetAssemblySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAssemblyResponder handles the response to the GetAssembly request. The method always
// closes the http.Response Body.
func (client GroupClient) GetAssemblyResponder(resp *http.Response) (result USQLAssembly, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetCredential retrieves the specified credential from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the schema. credentialName is the name of the credential.
func (client GroupClient) GetCredential(accountName string, databaseName string, credentialName string) (result USQLCredential, err error) {
	req, err := client.GetCredentialPreparer(accountName, databaseName, credentialName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetCredential", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetCredentialSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetCredential", resp, "Failure sending request")
		return
	}

	result, err = client.GetCredentialResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetCredential", resp, "Failure responding to request")
	}

	return
}

// GetCredentialPreparer prepares the GetCredential request.
func (client GroupClient) GetCredentialPreparer(accountName string, databaseName string, credentialName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"credentialName": autorest.Encode("path", credentialName),
		"databaseName":   autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/credentials/{credentialName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetCredentialSender sends the GetCredential request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetCredentialSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetCredentialResponder handles the response to the GetCredential request. The method always
// closes the http.Response Body.
func (client GroupClient) GetCredentialResponder(resp *http.Response) (result USQLCredential, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDatabase retrieves the specified database from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database.
func (client GroupClient) GetDatabase(accountName string, databaseName string) (result USQLDatabase, err error) {
	req, err := client.GetDatabasePreparer(accountName, databaseName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetDatabase", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDatabaseSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetDatabase", resp, "Failure sending request")
		return
	}

	result, err = client.GetDatabaseResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetDatabase", resp, "Failure responding to request")
	}

	return
}

// GetDatabasePreparer prepares the GetDatabase request.
func (client GroupClient) GetDatabasePreparer(accountName string, databaseName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetDatabaseSender sends the GetDatabase request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetDatabaseSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDatabaseResponder handles the response to the GetDatabase request. The method always
// closes the http.Response Body.
func (client GroupClient) GetDatabaseResponder(resp *http.Response) (result USQLDatabase, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetExternalDataSource retrieves the specified external data source from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the external data source. externalDataSourceName is the name of the external data source.
func (client GroupClient) GetExternalDataSource(accountName string, databaseName string, externalDataSourceName string) (result USQLExternalDataSource, err error) {
	req, err := client.GetExternalDataSourcePreparer(accountName, databaseName, externalDataSourceName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetExternalDataSource", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetExternalDataSourceSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetExternalDataSource", resp, "Failure sending request")
		return
	}

	result, err = client.GetExternalDataSourceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetExternalDataSource", resp, "Failure responding to request")
	}

	return
}

// GetExternalDataSourcePreparer prepares the GetExternalDataSource request.
func (client GroupClient) GetExternalDataSourcePreparer(accountName string, databaseName string, externalDataSourceName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":           autorest.Encode("path", databaseName),
		"externalDataSourceName": autorest.Encode("path", externalDataSourceName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/externaldatasources/{externalDataSourceName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetExternalDataSourceSender sends the GetExternalDataSource request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetExternalDataSourceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetExternalDataSourceResponder handles the response to the GetExternalDataSource request. The method always
// closes the http.Response Body.
func (client GroupClient) GetExternalDataSourceResponder(resp *http.Response) (result USQLExternalDataSource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcedure retrieves the specified procedure from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the procedure. schemaName is the name of the schema containing the procedure. procedureName
// is the name of the procedure.
func (client GroupClient) GetProcedure(accountName string, databaseName string, schemaName string, procedureName string) (result USQLProcedure, err error) {
	req, err := client.GetProcedurePreparer(accountName, databaseName, schemaName, procedureName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetProcedure", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcedureSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetProcedure", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcedureResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetProcedure", resp, "Failure responding to request")
	}

	return
}

// GetProcedurePreparer prepares the GetProcedure request.
func (client GroupClient) GetProcedurePreparer(accountName string, databaseName string, schemaName string, procedureName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":  autorest.Encode("path", databaseName),
		"procedureName": autorest.Encode("path", procedureName),
		"schemaName":    autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/procedures/{procedureName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetProcedureSender sends the GetProcedure request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetProcedureSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetProcedureResponder handles the response to the GetProcedure request. The method always
// closes the http.Response Body.
func (client GroupClient) GetProcedureResponder(resp *http.Response) (result USQLProcedure, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSchema retrieves the specified schema from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the schema. schemaName is the name of the schema.
func (client GroupClient) GetSchema(accountName string, databaseName string, schemaName string) (result USQLSchema, err error) {
	req, err := client.GetSchemaPreparer(accountName, databaseName, schemaName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSchema", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSchemaSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSchema", resp, "Failure sending request")
		return
	}

	result, err = client.GetSchemaResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSchema", resp, "Failure responding to request")
	}

	return
}

// GetSchemaPreparer prepares the GetSchema request.
func (client GroupClient) GetSchemaPreparer(accountName string, databaseName string, schemaName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSchemaSender sends the GetSchema request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetSchemaSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSchemaResponder handles the response to the GetSchema request. The method always
// closes the http.Response Body.
func (client GroupClient) GetSchemaResponder(resp *http.Response) (result USQLSchema, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSecret gets the specified secret in the specified database
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the secret. secretName is the name of the secret to get
func (client GroupClient) GetSecret(accountName string, databaseName string, secretName string) (result USQLSecret, err error) {
	req, err := client.GetSecretPreparer(accountName, databaseName, secretName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSecret", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSecret", resp, "Failure sending request")
		return
	}

	result, err = client.GetSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetSecret", resp, "Failure responding to request")
	}

	return
}

// GetSecretPreparer prepares the GetSecret request.
func (client GroupClient) GetSecretPreparer(accountName string, databaseName string, secretName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"secretName":   autorest.Encode("path", secretName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/secrets/{secretName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSecretSender sends the GetSecret request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSecretResponder handles the response to the GetSecret request. The method always
// closes the http.Response Body.
func (client GroupClient) GetSecretResponder(resp *http.Response) (result USQLSecret, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTable retrieves the specified table from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the table. schemaName is the name of the schema containing the table. tableName is the name
// of the table.
func (client GroupClient) GetTable(accountName string, databaseName string, schemaName string, tableName string) (result USQLTable, err error) {
	req, err := client.GetTablePreparer(accountName, databaseName, schemaName, tableName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTable", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTableSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTable", resp, "Failure sending request")
		return
	}

	result, err = client.GetTableResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTable", resp, "Failure responding to request")
	}

	return
}

// GetTablePreparer prepares the GetTable request.
func (client GroupClient) GetTablePreparer(accountName string, databaseName string, schemaName string, tableName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
		"tableName":    autorest.Encode("path", tableName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetTableSender sends the GetTable request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetTableSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTableResponder handles the response to the GetTable request. The method always
// closes the http.Response Body.
func (client GroupClient) GetTableResponder(resp *http.Response) (result USQLTable, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTablePartition retrieves the specified table partition from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the partition. schemaName is the name of the schema containing the partition. tableName is
// the name of the table containing the partition. partitionName is the name of the table partition.
func (client GroupClient) GetTablePartition(accountName string, databaseName string, schemaName string, tableName string, partitionName string) (result USQLTablePartition, err error) {
	req, err := client.GetTablePartitionPreparer(accountName, databaseName, schemaName, tableName, partitionName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTablePartition", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTablePartitionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTablePartition", resp, "Failure sending request")
		return
	}

	result, err = client.GetTablePartitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTablePartition", resp, "Failure responding to request")
	}

	return
}

// GetTablePartitionPreparer prepares the GetTablePartition request.
func (client GroupClient) GetTablePartitionPreparer(accountName string, databaseName string, schemaName string, tableName string, partitionName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":  autorest.Encode("path", databaseName),
		"partitionName": autorest.Encode("path", partitionName),
		"schemaName":    autorest.Encode("path", schemaName),
		"tableName":     autorest.Encode("path", tableName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/partitions/{partitionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetTablePartitionSender sends the GetTablePartition request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetTablePartitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTablePartitionResponder handles the response to the GetTablePartition request. The method always
// closes the http.Response Body.
func (client GroupClient) GetTablePartitionResponder(resp *http.Response) (result USQLTablePartition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTableStatistic retrieves the specified table statistics from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the statistics. schemaName is the name of the schema containing the statistics. tableName is
// the name of the table containing the statistics. statisticsName is the name of the table statistics.
func (client GroupClient) GetTableStatistic(accountName string, databaseName string, schemaName string, tableName string, statisticsName string) (result USQLTableStatistics, err error) {
	req, err := client.GetTableStatisticPreparer(accountName, databaseName, schemaName, tableName, statisticsName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableStatistic", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTableStatisticSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableStatistic", resp, "Failure sending request")
		return
	}

	result, err = client.GetTableStatisticResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableStatistic", resp, "Failure responding to request")
	}

	return
}

// GetTableStatisticPreparer prepares the GetTableStatistic request.
func (client GroupClient) GetTableStatisticPreparer(accountName string, databaseName string, schemaName string, tableName string, statisticsName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":   autorest.Encode("path", databaseName),
		"schemaName":     autorest.Encode("path", schemaName),
		"statisticsName": autorest.Encode("path", statisticsName),
		"tableName":      autorest.Encode("path", tableName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/statistics/{statisticsName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetTableStatisticSender sends the GetTableStatistic request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetTableStatisticSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTableStatisticResponder handles the response to the GetTableStatistic request. The method always
// closes the http.Response Body.
func (client GroupClient) GetTableStatisticResponder(resp *http.Response) (result USQLTableStatistics, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTableType retrieves the specified table type from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the table type. schemaName is the name of the schema containing the table type.
// tableTypeName is the name of the table type to retrieve.
func (client GroupClient) GetTableType(accountName string, databaseName string, schemaName string, tableTypeName string) (result USQLTableType, err error) {
	req, err := client.GetTableTypePreparer(accountName, databaseName, schemaName, tableTypeName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableType", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTableTypeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableType", resp, "Failure sending request")
		return
	}

	result, err = client.GetTableTypeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableType", resp, "Failure responding to request")
	}

	return
}

// GetTableTypePreparer prepares the GetTableType request.
func (client GroupClient) GetTableTypePreparer(accountName string, databaseName string, schemaName string, tableTypeName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":  autorest.Encode("path", databaseName),
		"schemaName":    autorest.Encode("path", schemaName),
		"tableTypeName": autorest.Encode("path", tableTypeName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tabletypes/{tableTypeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetTableTypeSender sends the GetTableType request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetTableTypeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTableTypeResponder handles the response to the GetTableType request. The method always
// closes the http.Response Body.
func (client GroupClient) GetTableTypeResponder(resp *http.Response) (result USQLTableType, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTableValuedFunction retrieves the specified table valued function from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the table valued function. schemaName is the name of the schema containing the table valued
// function. tableValuedFunctionName is the name of the tableValuedFunction.
func (client GroupClient) GetTableValuedFunction(accountName string, databaseName string, schemaName string, tableValuedFunctionName string) (result USQLTableValuedFunction, err error) {
	req, err := client.GetTableValuedFunctionPreparer(accountName, databaseName, schemaName, tableValuedFunctionName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableValuedFunction", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTableValuedFunctionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableValuedFunction", resp, "Failure sending request")
		return
	}

	result, err = client.GetTableValuedFunctionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetTableValuedFunction", resp, "Failure responding to request")
	}

	return
}

// GetTableValuedFunctionPreparer prepares the GetTableValuedFunction request.
func (client GroupClient) GetTableValuedFunctionPreparer(accountName string, databaseName string, schemaName string, tableValuedFunctionName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName":            autorest.Encode("path", databaseName),
		"schemaName":              autorest.Encode("path", schemaName),
		"tableValuedFunctionName": autorest.Encode("path", tableValuedFunctionName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tablevaluedfunctions/{tableValuedFunctionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetTableValuedFunctionSender sends the GetTableValuedFunction request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetTableValuedFunctionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTableValuedFunctionResponder handles the response to the GetTableValuedFunction request. The method always
// closes the http.Response Body.
func (client GroupClient) GetTableValuedFunctionResponder(resp *http.Response) (result USQLTableValuedFunction, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetView retrieves the specified view from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the view. schemaName is the name of the schema containing the view. viewName is the name of
// the view.
func (client GroupClient) GetView(accountName string, databaseName string, schemaName string, viewName string) (result USQLView, err error) {
	req, err := client.GetViewPreparer(accountName, databaseName, schemaName, viewName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetView", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetViewSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetView", resp, "Failure sending request")
		return
	}

	result, err = client.GetViewResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "GetView", resp, "Failure responding to request")
	}

	return
}

// GetViewPreparer prepares the GetView request.
func (client GroupClient) GetViewPreparer(accountName string, databaseName string, schemaName string, viewName string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
		"viewName":     autorest.Encode("path", viewName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/views/{viewName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetViewSender sends the GetView request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetViewSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetViewResponder handles the response to the GetView request. The method always
// closes the http.Response Body.
func (client GroupClient) GetViewResponder(resp *http.Response) (result USQLView, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListAssemblies retrieves the list of assemblies from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the assembly. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData expansion.
// Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product
// data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client GroupClient) ListAssemblies(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLAssemblyList, err error) {
	req, err := client.ListAssembliesPreparer(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListAssembliesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", resp, "Failure sending request")
		return
	}

	result, err = client.ListAssembliesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", resp, "Failure responding to request")
	}

	return
}

// ListAssembliesPreparer prepares the ListAssemblies request.
func (client GroupClient) ListAssembliesPreparer(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/assemblies", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListAssembliesSender sends the ListAssemblies request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListAssembliesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListAssembliesResponder handles the response to the ListAssemblies request. The method always
// closes the http.Response Body.
func (client GroupClient) ListAssembliesResponder(resp *http.Response) (result USQLAssemblyList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListAssembliesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListAssembliesNextResults(lastResults USQLAssemblyList) (result USQLAssemblyList, err error) {
	req, err := lastResults.USQLAssemblyListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListAssembliesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", resp, "Failure sending next results request")
	}

	result, err = client.ListAssembliesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListAssemblies", resp, "Failure responding to next results request")
	}

	return
}

// ListAssembliesComplete gets all elements from the list without paging.
func (client GroupClient) ListAssembliesComplete(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLAssemblyClr, <-chan error) {
	resultChan := make(chan USQLAssemblyClr)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListAssemblies(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListAssembliesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListCredentials retrieves the list of credentials from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the schema. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData expansion.
// Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product
// data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client GroupClient) ListCredentials(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLCredentialList, err error) {
	req, err := client.ListCredentialsPreparer(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListCredentialsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", resp, "Failure sending request")
		return
	}

	result, err = client.ListCredentialsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", resp, "Failure responding to request")
	}

	return
}

// ListCredentialsPreparer prepares the ListCredentials request.
func (client GroupClient) ListCredentialsPreparer(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/credentials", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListCredentialsSender sends the ListCredentials request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListCredentialsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListCredentialsResponder handles the response to the ListCredentials request. The method always
// closes the http.Response Body.
func (client GroupClient) ListCredentialsResponder(resp *http.Response) (result USQLCredentialList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListCredentialsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListCredentialsNextResults(lastResults USQLCredentialList) (result USQLCredentialList, err error) {
	req, err := lastResults.USQLCredentialListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListCredentialsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", resp, "Failure sending next results request")
	}

	result, err = client.ListCredentialsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListCredentials", resp, "Failure responding to next results request")
	}

	return
}

// ListCredentialsComplete gets all elements from the list without paging.
func (client GroupClient) ListCredentialsComplete(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLCredential, <-chan error) {
	resultChan := make(chan USQLCredential)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListCredentials(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListCredentialsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListDatabases retrieves the list of databases from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. filter is oData filter.
// Optional. top is the number of items to return. Optional. skip is the number of items to skip over before returning
// elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved resources, e.g.
// Categories?$expand=Products would expand Product data in line with each Category entry. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListDatabases(accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLDatabaseList, err error) {
	req, err := client.ListDatabasesPreparer(accountName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDatabasesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", resp, "Failure sending request")
		return
	}

	result, err = client.ListDatabasesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", resp, "Failure responding to request")
	}

	return
}

// ListDatabasesPreparer prepares the ListDatabases request.
func (client GroupClient) ListDatabasesPreparer(accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPath("/catalog/usql/databases"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListDatabasesSender sends the ListDatabases request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListDatabasesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListDatabasesResponder handles the response to the ListDatabases request. The method always
// closes the http.Response Body.
func (client GroupClient) ListDatabasesResponder(resp *http.Response) (result USQLDatabaseList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListDatabasesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListDatabasesNextResults(lastResults USQLDatabaseList) (result USQLDatabaseList, err error) {
	req, err := lastResults.USQLDatabaseListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListDatabasesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", resp, "Failure sending next results request")
	}

	result, err = client.ListDatabasesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListDatabases", resp, "Failure responding to next results request")
	}

	return
}

// ListDatabasesComplete gets all elements from the list without paging.
func (client GroupClient) ListDatabasesComplete(accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLDatabase, <-chan error) {
	resultChan := make(chan USQLDatabase)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListDatabases(accountName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListDatabasesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListExternalDataSources retrieves the list of external data sources from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the external data sources. filter is oData filter. Optional. top is the number of items to
// return. Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData
// expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would
// expand Product data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits
// the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
// orderby is orderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc"
// depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is
// the Boolean value of true or false to request a count of the matching resources included with the resources in the
// response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListExternalDataSources(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLExternalDataSourceList, err error) {
	req, err := client.ListExternalDataSourcesPreparer(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListExternalDataSourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", resp, "Failure sending request")
		return
	}

	result, err = client.ListExternalDataSourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", resp, "Failure responding to request")
	}

	return
}

// ListExternalDataSourcesPreparer prepares the ListExternalDataSources request.
func (client GroupClient) ListExternalDataSourcesPreparer(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/externaldatasources", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListExternalDataSourcesSender sends the ListExternalDataSources request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListExternalDataSourcesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListExternalDataSourcesResponder handles the response to the ListExternalDataSources request. The method always
// closes the http.Response Body.
func (client GroupClient) ListExternalDataSourcesResponder(resp *http.Response) (result USQLExternalDataSourceList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListExternalDataSourcesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListExternalDataSourcesNextResults(lastResults USQLExternalDataSourceList) (result USQLExternalDataSourceList, err error) {
	req, err := lastResults.USQLExternalDataSourceListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListExternalDataSourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", resp, "Failure sending next results request")
	}

	result, err = client.ListExternalDataSourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListExternalDataSources", resp, "Failure responding to next results request")
	}

	return
}

// ListExternalDataSourcesComplete gets all elements from the list without paging.
func (client GroupClient) ListExternalDataSourcesComplete(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLExternalDataSource, <-chan error) {
	resultChan := make(chan USQLExternalDataSource)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListExternalDataSources(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListExternalDataSourcesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListProcedures retrieves the list of procedures from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the procedures. schemaName is the name of the schema containing the procedures. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListProcedures(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLProcedureList, err error) {
	req, err := client.ListProceduresPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProceduresSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", resp, "Failure sending request")
		return
	}

	result, err = client.ListProceduresResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", resp, "Failure responding to request")
	}

	return
}

// ListProceduresPreparer prepares the ListProcedures request.
func (client GroupClient) ListProceduresPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/procedures", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListProceduresSender sends the ListProcedures request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListProceduresSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListProceduresResponder handles the response to the ListProcedures request. The method always
// closes the http.Response Body.
func (client GroupClient) ListProceduresResponder(resp *http.Response) (result USQLProcedureList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListProceduresNextResults retrieves the next set of results, if any.
func (client GroupClient) ListProceduresNextResults(lastResults USQLProcedureList) (result USQLProcedureList, err error) {
	req, err := lastResults.USQLProcedureListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListProceduresSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", resp, "Failure sending next results request")
	}

	result, err = client.ListProceduresResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListProcedures", resp, "Failure responding to next results request")
	}

	return
}

// ListProceduresComplete gets all elements from the list without paging.
func (client GroupClient) ListProceduresComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLProcedure, <-chan error) {
	resultChan := make(chan USQLProcedure)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListProcedures(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListProceduresNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListSchemas retrieves the list of schemas from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the schema. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData expansion.
// Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would expand Product
// data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client GroupClient) ListSchemas(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLSchemaList, err error) {
	req, err := client.ListSchemasPreparer(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSchemasSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", resp, "Failure sending request")
		return
	}

	result, err = client.ListSchemasResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", resp, "Failure responding to request")
	}

	return
}

// ListSchemasPreparer prepares the ListSchemas request.
func (client GroupClient) ListSchemasPreparer(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListSchemasSender sends the ListSchemas request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListSchemasSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListSchemasResponder handles the response to the ListSchemas request. The method always
// closes the http.Response Body.
func (client GroupClient) ListSchemasResponder(resp *http.Response) (result USQLSchemaList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSchemasNextResults retrieves the next set of results, if any.
func (client GroupClient) ListSchemasNextResults(lastResults USQLSchemaList) (result USQLSchemaList, err error) {
	req, err := lastResults.USQLSchemaListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListSchemasSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", resp, "Failure sending next results request")
	}

	result, err = client.ListSchemasResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListSchemas", resp, "Failure responding to next results request")
	}

	return
}

// ListSchemasComplete gets all elements from the list without paging.
func (client GroupClient) ListSchemasComplete(accountName string, databaseName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLSchema, <-chan error) {
	resultChan := make(chan USQLSchema)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListSchemas(accountName, databaseName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListSchemasNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTablePartitions retrieves the list of table partitions from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the partitions. schemaName is the name of the schema containing the partitions. tableName is
// the name of the table containing the partitions. filter is oData filter. Optional. top is the number of items to
// return. Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData
// expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would
// expand Product data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits
// the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
// orderby is orderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc"
// depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is
// the Boolean value of true or false to request a count of the matching resources included with the resources in the
// response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListTablePartitions(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTablePartitionList, err error) {
	req, err := client.ListTablePartitionsPreparer(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTablePartitionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", resp, "Failure sending request")
		return
	}

	result, err = client.ListTablePartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", resp, "Failure responding to request")
	}

	return
}

// ListTablePartitionsPreparer prepares the ListTablePartitions request.
func (client GroupClient) ListTablePartitionsPreparer(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
		"tableName":    autorest.Encode("path", tableName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/partitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTablePartitionsSender sends the ListTablePartitions request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTablePartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTablePartitionsResponder handles the response to the ListTablePartitions request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTablePartitionsResponder(resp *http.Response) (result USQLTablePartitionList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTablePartitionsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTablePartitionsNextResults(lastResults USQLTablePartitionList) (result USQLTablePartitionList, err error) {
	req, err := lastResults.USQLTablePartitionListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTablePartitionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", resp, "Failure sending next results request")
	}

	result, err = client.ListTablePartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTablePartitions", resp, "Failure responding to next results request")
	}

	return
}

// ListTablePartitionsComplete gets all elements from the list without paging.
func (client GroupClient) ListTablePartitionsComplete(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLTablePartition, <-chan error) {
	resultChan := make(chan USQLTablePartition)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTablePartitions(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTablePartitionsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTables retrieves the list of tables from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the tables. schemaName is the name of the schema containing the tables. filter is oData
// filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over before
// returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListTables(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTableList, err error) {
	req, err := client.ListTablesPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTablesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", resp, "Failure sending request")
		return
	}

	result, err = client.ListTablesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", resp, "Failure responding to request")
	}

	return
}

// ListTablesPreparer prepares the ListTables request.
func (client GroupClient) ListTablesPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTablesSender sends the ListTables request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTablesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTablesResponder handles the response to the ListTables request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTablesResponder(resp *http.Response) (result USQLTableList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTablesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTablesNextResults(lastResults USQLTableList) (result USQLTableList, err error) {
	req, err := lastResults.USQLTableListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTablesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", resp, "Failure sending next results request")
	}

	result, err = client.ListTablesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTables", resp, "Failure responding to next results request")
	}

	return
}

// ListTablesComplete gets all elements from the list without paging.
func (client GroupClient) ListTablesComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLTable, <-chan error) {
	resultChan := make(chan USQLTable)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTables(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTablesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTableStatistics retrieves the list of table statistics from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the statistics. schemaName is the name of the schema containing the statistics. tableName is
// the name of the table containing the statistics. filter is oData filter. Optional. top is the number of items to
// return. Optional. skip is the number of items to skip over before returning elements. Optional. expand is oData
// expansion. Expand related resources in line with the retrieved resources, e.g. Categories?$expand=Products would
// expand Product data in line with each Category entry. Optional. selectParameter is oData Select statement. Limits
// the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
// orderby is orderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc"
// depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is
// the Boolean value of true or false to request a count of the matching resources included with the resources in the
// response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListTableStatistics(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTableStatisticsList, err error) {
	req, err := client.ListTableStatisticsPreparer(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTableStatisticsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", resp, "Failure sending request")
		return
	}

	result, err = client.ListTableStatisticsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", resp, "Failure responding to request")
	}

	return
}

// ListTableStatisticsPreparer prepares the ListTableStatistics request.
func (client GroupClient) ListTableStatisticsPreparer(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
		"tableName":    autorest.Encode("path", tableName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/statistics", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTableStatisticsSender sends the ListTableStatistics request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTableStatisticsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTableStatisticsResponder handles the response to the ListTableStatistics request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTableStatisticsResponder(resp *http.Response) (result USQLTableStatisticsList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTableStatisticsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTableStatisticsNextResults(lastResults USQLTableStatisticsList) (result USQLTableStatisticsList, err error) {
	req, err := lastResults.USQLTableStatisticsListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTableStatisticsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", resp, "Failure sending next results request")
	}

	result, err = client.ListTableStatisticsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableStatistics", resp, "Failure responding to next results request")
	}

	return
}

// ListTableStatisticsComplete gets all elements from the list without paging.
func (client GroupClient) ListTableStatisticsComplete(accountName string, databaseName string, schemaName string, tableName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLTableStatistics, <-chan error) {
	resultChan := make(chan USQLTableStatistics)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTableStatistics(accountName, databaseName, schemaName, tableName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTableStatisticsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTableTypes retrieves the list of table types from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the table types. schemaName is the name of the schema containing the table types. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListTableTypes(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTableTypeList, err error) {
	req, err := client.ListTableTypesPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTableTypesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", resp, "Failure sending request")
		return
	}

	result, err = client.ListTableTypesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", resp, "Failure responding to request")
	}

	return
}

// ListTableTypesPreparer prepares the ListTableTypes request.
func (client GroupClient) ListTableTypesPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tabletypes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTableTypesSender sends the ListTableTypes request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTableTypesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTableTypesResponder handles the response to the ListTableTypes request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTableTypesResponder(resp *http.Response) (result USQLTableTypeList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTableTypesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTableTypesNextResults(lastResults USQLTableTypeList) (result USQLTableTypeList, err error) {
	req, err := lastResults.USQLTableTypeListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTableTypesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", resp, "Failure sending next results request")
	}

	result, err = client.ListTableTypesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableTypes", resp, "Failure responding to next results request")
	}

	return
}

// ListTableTypesComplete gets all elements from the list without paging.
func (client GroupClient) ListTableTypesComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLTableType, <-chan error) {
	resultChan := make(chan USQLTableType)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTableTypes(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTableTypesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTableValuedFunctions retrieves the list of table valued functions from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the table valued functions. schemaName is the name of the schema containing the table valued
// functions. filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of
// items to skip over before returning elements. Optional. expand is oData expansion. Expand related resources in line
// with the retrieved resources, e.g. Categories?$expand=Products would expand Product data in line with each Category
// entry. Optional. selectParameter is oData Select statement. Limits the properties on each entry to just those
// requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more
// comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the
// values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to
// request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
// Optional.
func (client GroupClient) ListTableValuedFunctions(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTableValuedFunctionList, err error) {
	req, err := client.ListTableValuedFunctionsPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTableValuedFunctionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", resp, "Failure sending request")
		return
	}

	result, err = client.ListTableValuedFunctionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", resp, "Failure responding to request")
	}

	return
}

// ListTableValuedFunctionsPreparer prepares the ListTableValuedFunctions request.
func (client GroupClient) ListTableValuedFunctionsPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/tablevaluedfunctions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTableValuedFunctionsSender sends the ListTableValuedFunctions request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTableValuedFunctionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTableValuedFunctionsResponder handles the response to the ListTableValuedFunctions request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTableValuedFunctionsResponder(resp *http.Response) (result USQLTableValuedFunctionList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTableValuedFunctionsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTableValuedFunctionsNextResults(lastResults USQLTableValuedFunctionList) (result USQLTableValuedFunctionList, err error) {
	req, err := lastResults.USQLTableValuedFunctionListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTableValuedFunctionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", resp, "Failure sending next results request")
	}

	result, err = client.ListTableValuedFunctionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTableValuedFunctions", resp, "Failure responding to next results request")
	}

	return
}

// ListTableValuedFunctionsComplete gets all elements from the list without paging.
func (client GroupClient) ListTableValuedFunctionsComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLTableValuedFunction, <-chan error) {
	resultChan := make(chan USQLTableValuedFunction)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTableValuedFunctions(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTableValuedFunctionsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListTypes retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the types. schemaName is the name of the schema containing the types. filter is oData
// filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over before
// returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListTypes(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLTypeList, err error) {
	req, err := client.ListTypesPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTypesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", resp, "Failure sending request")
		return
	}

	result, err = client.ListTypesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", resp, "Failure responding to request")
	}

	return
}

// ListTypesPreparer prepares the ListTypes request.
func (client GroupClient) ListTypesPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/types", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListTypesSender sends the ListTypes request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListTypesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListTypesResponder handles the response to the ListTypes request. The method always
// closes the http.Response Body.
func (client GroupClient) ListTypesResponder(resp *http.Response) (result USQLTypeList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTypesNextResults retrieves the next set of results, if any.
func (client GroupClient) ListTypesNextResults(lastResults USQLTypeList) (result USQLTypeList, err error) {
	req, err := lastResults.USQLTypeListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListTypesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", resp, "Failure sending next results request")
	}

	result, err = client.ListTypesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListTypes", resp, "Failure responding to next results request")
	}

	return
}

// ListTypesComplete gets all elements from the list without paging.
func (client GroupClient) ListTypesComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLType, <-chan error) {
	resultChan := make(chan USQLType)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListTypes(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListTypesNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListViews retrieves the list of views from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the views. schemaName is the name of the schema containing the views. filter is oData
// filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over before
// returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories?$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client GroupClient) ListViews(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (result USQLViewList, err error) {
	req, err := client.ListViewsPreparer(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListViewsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", resp, "Failure sending request")
		return
	}

	result, err = client.ListViewsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", resp, "Failure responding to request")
	}

	return
}

// ListViewsPreparer prepares the ListViews request.
func (client GroupClient) ListViewsPreparer(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"schemaName":   autorest.Encode("path", schemaName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/schemas/{schemaName}/views", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListViewsSender sends the ListViews request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListViewsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListViewsResponder handles the response to the ListViews request. The method always
// closes the http.Response Body.
func (client GroupClient) ListViewsResponder(resp *http.Response) (result USQLViewList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListViewsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListViewsNextResults(lastResults USQLViewList) (result USQLViewList, err error) {
	req, err := lastResults.USQLViewListPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListViewsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", resp, "Failure sending next results request")
	}

	result, err = client.ListViewsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "ListViews", resp, "Failure responding to next results request")
	}

	return
}

// ListViewsComplete gets all elements from the list without paging.
func (client GroupClient) ListViewsComplete(accountName string, databaseName string, schemaName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, cancel <-chan struct{}) (<-chan USQLView, <-chan error) {
	resultChan := make(chan USQLView)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListViews(accountName, databaseName, schemaName, filter, top, skip, expand, selectParameter, orderby, count)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListViewsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// UpdateSecret modifies the specified secret for use with external data sources in the specified database
//
// accountName is the Azure Data Lake Analytics account to execute catalog operations on. databaseName is the name of
// the database containing the secret. secretName is the name of the secret. parameters is the parameters required to
// modify the secret (name and password)
func (client GroupClient) UpdateSecret(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (result USQLSecret, err error) {
	req, err := client.UpdateSecretPreparer(accountName, databaseName, secretName, parameters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "UpdateSecret", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSecretSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "UpdateSecret", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSecretResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "catalog.GroupClient", "UpdateSecret", resp, "Failure responding to request")
	}

	return
}

// UpdateSecretPreparer prepares the UpdateSecret request.
func (client GroupClient) UpdateSecretPreparer(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":          accountName,
		"adlaCatalogDnsSuffix": client.AdlaCatalogDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"databaseName": autorest.Encode("path", databaseName),
		"secretName":   autorest.Encode("path", secretName),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlaCatalogDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/catalog/usql/databases/{databaseName}/secrets/{secretName}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateSecretSender sends the UpdateSecret request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) UpdateSecretSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateSecretResponder handles the response to the UpdateSecret request. The method always
// closes the http.Response Body.
func (client GroupClient) UpdateSecretResponder(resp *http.Response) (result USQLSecret, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
